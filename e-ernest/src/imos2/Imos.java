package imos2;


import imos2.IInteraction;

import java.util.ArrayList;
import java.util.List;
import ernest.ITracer;

/**
 * The Intrinsically Motivated Schema mechanism.
 * @author ogeorgeon
 */

public class Imos implements IImos 
{	
	/** Default maximum length of a schema (For the schema to be chosen as an intention) */
	public final int SCHEMA_MAX_LENGTH = 100;

	/** Default Activation threshold (The weight threshold for higher-level learning with the second learning mechanism). */
	public final int ACTIVATION_THRESH = 1;

	/** Regularity sensibility threshold (The weight threshold for an act to become reliable). */
	private int m_regularitySensibilityThreshold = 6;

	/** A list of all the acts ever created. Aimed to replace schemas and acts*/
	private ArrayList<IInteraction> m_interactions = new ArrayList<IInteraction>(2000);
	
	/** Counter of learned schemas for tracing */
	private int m_nbSchemaLearned = 0;
	
	/** The Tracer. */
	private ITracer<Object> m_tracer = null; //new Tracer("trace.txt");

	/** A representation of the internal state for display in the environment. */
	private String m_internalState = "";
	
	/** Counter of cognitive cycles. */
	private int m_imosCycle = 0;
	
	/**
	 * Constructor for the sequential system.
	 * @param regularitySensibilityThreshold  The regularity sensibility threshold.
	 * A lower value favors the faster adoption of possibly less satisfying sequences, 
	 * a higher value favors the slower adoption of possibly more satisfying sequences.
	 */
	public Imos(int regularitySensibilityThreshold)
	{
		m_regularitySensibilityThreshold = regularitySensibilityThreshold;
	}

	public void setRegularityThreshold(int regularityThreshold)
	{
		m_regularitySensibilityThreshold = regularityThreshold;
	}
	
	/**
	 * @param tracer The tracer.
	 */
	public void setTracer(ITracer<Object> tracer)
	{
		m_tracer = tracer;
	}
	
	/**
	 * Get a string description of the imos's internal state for display in the environment.
	 * @return A representation of the imos's internal state
	 */
	public String getInternalState()
	{
		return m_internalState;
	}

	/**
	 * Construct a new interaction or retrieve the interaction if it already exists.
	 * @param moveLabel The label of the interaction's action in the environment.
	 * @param effectLabel The label of the interaction's stimuli generated by the action.
	 * @param satisfaction The interaction's satisfaction (only needed in case this interaction was not 
	 * yet declared in imos).
	 * @return The interaction that was created or that already existed.
	 */
	public IInteraction addInteraction(String moveLabel, String effectLabel, int satisfaction)
	{
		// Primitive satisfactions are multiplied by 10 internally for rounding issues.   
		// (this value does not impact the agent's behavior)
		IInteraction i = Interaction.createPrimitiveInteraction(moveLabel, effectLabel, satisfaction * 10);
		
		int j = m_interactions.indexOf(i);
		if (j == -1)
			// The act does not exist
			m_interactions.add(i);
		else 
			// The act already exists: return a pointer to it.
			i =  m_interactions.get(j);
		
		System.out.println("Primitive interaction " + i.toString() + " " + i.getEnactionValue());
		return i;		
	}

	/**
	 * Add a composite schema and its succeeding act that represent a composite possibility 
	 * of interaction between Ernest and its environment. 
	 * @param contextInteraction The context Act.
	 * @param intentionInteraction The intention Act.
	 * @return The schema made of the two specified acts, whether it has been created or it already existed. 
	 */
    private IInteraction addCompositeInteraction(IInteraction contextInteraction, IInteraction intentionInteraction)
    {
    	IInteraction i = Interaction.createCompositeInteraction(contextInteraction, intentionInteraction);
    	
		int j = m_interactions.indexOf(i);
		if (j == -1)
		{
			// The schema does not exist: create its succeeding act and add it to Ernest's memory
			m_interactions.add(i);
			m_nbSchemaLearned++;
		}
		else
			// The schema already exists: return a pointer to it.
			i =  m_interactions.get(j);
    	return i;
    }

	/**
	 * Track the current enaction. 
	 * Use the intended primitive act and the effect.
	 * Generates the enacted primitive act, the top enacted act, and the top remaining act.
	 * @param enaction The current enaction.
	 */
	public void track(IEnaction enaction) 
	{
		m_imosCycle++;		
		
		IInteraction intendedPrimitiveInteraction = enaction.getIntendedPrimitiveInteraction();
		IInteraction enactedPrimitiveInteraction  = null;
		IInteraction topEnactedInteraction        = null;
		IInteraction topRemainingInteraction      = null;

		// If we are not on startup
		if (intendedPrimitiveInteraction != null)
		{
			// Compute the enacted primitive act from the intended act and the effect.
			// Compute the enaction value of interactions that were not yet recorded
			enactedPrimitiveInteraction = addInteraction(intendedPrimitiveInteraction.getMoveLabel(), enaction.getEffect().getLabel(), 0);

			// Compute the top actually enacted act
			//topEnactedInteraction = enactedInteraction(enactedPrimitiveInteraction, enaction);
			// TODO compute the actually enacted interaction.
			
			// Update the prescriber hierarchy.
			if (intendedPrimitiveInteraction.equals(enactedPrimitiveInteraction)) 
				topRemainingInteraction = intendedPrimitiveInteraction.updatePrescriber();
			else
				intendedPrimitiveInteraction.terminate();
			
			System.out.println("Enacted " + topEnactedInteraction );
			
			// Compute the next intention, null if we have reached the end of the intended act.
			//topRemainingInteraction = nextInteraction(intendedPrimitiveInteraction, enactedPrimitiveInteraction);			
		}					
		
		// Update the current enaction
		enaction.setEnactedPrimitiveInteraction(enactedPrimitiveInteraction);
		enaction.setTopEnactedInteraction(topEnactedInteraction);
		enaction.setTopRemainingInteraction(topRemainingInteraction);

		// Trace
		enaction.traceTrack(m_tracer);
	}
	
	/**
	 * Terminate the current enaction.
	 * Use the top intended interaction, the top enacted interaction, the previous learning context, and the initial learning context.
	 * Generates the final activation context and the final learning context.
	 * Record or reinforce the learned acts and schemes. 
	 * @param enaction The current enaction.
	 */
	public void terminate(IEnaction enaction)
	{
		IInteraction topIntendedAct = enaction.getTopInteraction();
		IInteraction topEnactedAct  = enaction.getTopEnactedInteraction();
		ArrayList<IInteraction> previousLearningContext = enaction.getPreviousLearningContext();
		ArrayList<IInteraction> initialLearningContext = enaction.getInitialLearningContext();
		
		// if we are not on startup
		if (topEnactedAct != null)
		{
			// Surprise if the enacted act is not that intended
			if (topIntendedAct != topEnactedAct) 
			{
				m_internalState= "!";
				enaction.setCorrect(false);
			}
			
//			// Compute the performed act
//			// (the act based on the schema that was originally intended)
//			
//			IAct performedAct = null;
//
//			ISchema intendedSchema = topIntendedAct.getSchema();
//			
//			if (intendedSchema == topEnactedAct.getSchema())
//				// The intended schema was enacted
//				performedAct = topEnactedAct;
//			else	
//				// The intended schema was not enacted: the performed act is the intended schema with fail status
//				//performedAct = m_episodicMemory.addFailingInteraction(intendedSchema,topEnactedAct.getSatisfaction());
//				performedAct = addFailingInteraction(intendedSchema,topEnactedAct.getEnactionValue());
//			
//			//m_tracer.addEventElement("top_performed", performedAct.getLabel() );
//			System.out.println("Performed " + performedAct );
			
			// learn from the  context and the performed act
			//m_episodicMemory.resetLearnCount();
			m_nbSchemaLearned = 0;
			//ArrayList<IAct> streamContextList = m_episodicMemory.record(initialLearningContext, performedAct);
			//ArrayList<IInteraction> streamContextList = record(initialLearningContext, performedAct);
			ArrayList<IInteraction> streamContextList = record(initialLearningContext, topEnactedAct);
						
			// learn from the base context and the stream act			
			 if (streamContextList.size() > 0) // TODO find a better way than relying on the enacted act being on the top of the list
			 {
				 IInteraction streamAct = streamContextList.get(0); // The stream act is the first learned 
				 System.out.println("Streaming " + streamAct);
				 if (streamAct.getEnactionWeight() > ACTIVATION_THRESH)
					 //m_episodicMemory.record(previousLearningContext, streamAct);
					 record(previousLearningContext, streamAct);
			 }

			// learn from the current context and the actually enacted act			
			//if (topEnactedAct != performedAct)
			{
				System.out.println("Learn from enacted");
				//List<IAct> streamContextList2 = m_episodicMemory.record(initialLearningContext, topEnactedAct);
				List<IInteraction> streamContextList2 = record(initialLearningContext, topEnactedAct);
				// learn from the base context and the streamAct2
				if (streamContextList2.size() > 0)
				{
					IInteraction streamAct2 = streamContextList2.get(0);
					System.out.println("Streaming2 " + streamAct2 );
					if (streamAct2.getEnactionWeight() > ACTIVATION_THRESH)
						//m_episodicMemory.record(previousLearningContext, streamAct2);
						record(previousLearningContext, streamAct2);
				}
			}	
			
			//enaction.setFinalContext(topEnactedAct, performedAct, streamContextList);			
			enaction.setFinalContext(topEnactedAct, topEnactedAct, streamContextList);			
		}
		//enaction.setNbActLearned(m_episodicMemory.getLearnCount());
		enaction.setNbActLearned(m_nbSchemaLearned);
		enaction.traceTerminate(m_tracer);

	}

	/**
	 * Learn from an enacted intention after a given context.
	 * Returns the list of learned acts that are based on reliable subacts. The first act of the list is the stream act.
	 * @param contextList The list of acts that constitute the context in which the learning occurs.
	 * @param intentionAct The intention.
	 * @return A list of the acts created from the learning. The first act of the list is the stream act if the first act of the contextList was the performed act.
	 */
	private ArrayList<IInteraction> record(List<IInteraction> contextList, IInteraction intentionAct)
	{
		ArrayList<IInteraction> newContextList= new ArrayList<IInteraction>(20);
		
		if (intentionAct != null)
		{
			// For each act in the context ...
			for (IInteraction contextInteraction : contextList)
			{
				// Build a new schema with the context act and the intention act 
				//ISchema newSchema = addCompositeInteraction(contextAct, intentionAct);
				IInteraction newInteraction = addCompositeInteraction(contextInteraction, intentionAct);
				//newSchema.incWeight(m_regularitySensibilityThreshold);
				newInteraction.setEnactionWeight(newInteraction.getEnactionWeight() + 1);
				//System.out.println("learned " + newSchema.getLabel());
				
					// Created acts are part of the context 
					// if their context and intention have passed the regularity
					// if they are based on reliable noï¿½mes
				if ((contextInteraction.getEnactionWeight() > m_regularitySensibilityThreshold) &&
  				   (intentionAct.getEnactionWeight() > m_regularitySensibilityThreshold))
				{
					newContextList.add(newInteraction);
					// System.out.println("Reliable schema " + newSchema);
				}
			}
		}
		return newContextList; 
	}

	public ArrayList<IInteraction> getInteractions()
	{
		return m_interactions;
	}

	public int getCounter() 
	{
		return m_imosCycle;
	}
}
